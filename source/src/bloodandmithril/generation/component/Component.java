package bloodandmithril.generation.component;

import static com.google.common.collect.Lists.newArrayList;
import static com.google.common.collect.Maps.newHashMap;

import java.io.Serializable;
import java.util.Collection;
import java.util.Map;

import bloodandmithril.core.Copyright;
import bloodandmithril.generation.ChunkGenerator;
import bloodandmithril.generation.Structure;
import bloodandmithril.generation.component.components.stemming.interfaces.Interface;
import bloodandmithril.util.datastructure.Boundaries;
import bloodandmithril.world.topography.tile.Tile;

/**
 * A Component is a blueprint for entities to be generated by {@link ChunkGenerator}, that live inside {@link Structure}s
 *
 * @author Matt
 */
@Copyright("Matthew Peck 2014")
public abstract class Component implements Serializable {
	private static final long serialVersionUID = 7335059774362898508L;

	/** {@link Boundaries} of this {@link Component} */
	protected final Boundaries boundaries;

	/** The key of the {@link Structure} this {@link Component} exists on */
	private final int structureKey;
	
	/** {@link Interface}s on this {@link Component} */
	private final Map<Interface, Component> interfaces = newHashMap();

	/**
	 * Constructor
	 */
	protected Component(final Boundaries boundaries, final int structureKey) {
		this.boundaries = boundaries;
		this.structureKey = structureKey;
		generateInterfaces();
	}


	/**
	 * Gets the foreground tile of this component
	 */
	public abstract Tile getForegroundTile(int worldTileX, int worldTileY);


	/**
	 * Gets the background tile of this component
	 */
	public abstract Tile getBackgroundTile(int worldTileX, int worldTileY);
	
	
	/**
	 * Generates interfaces for this {@link Component}
	 */
	public abstract void generateInterfaces();


	/**
	 * See {@link #boundaries}
	 */
	public Boundaries getBoundaries() {
		return boundaries;
	}


	/**
	 * Gets the unique key of the structure which this {@link Component} exists on
	 */
	public int getStructureKey() {
		return structureKey;
	}
	
	
	/**
	 * @return free {@link Interface}s
	 */
	public Collection<Interface> getFreeInterfaces() {
		Collection<Interface> interfacesToReturn = newArrayList();
		
		interfaces.entrySet().stream().filter(entry -> entry.getValue() == null).forEach(entry -> {
			interfacesToReturn.add(entry.getKey());
		});
				
		return interfacesToReturn;
	}
	
	
	/**
	 * @param iface {@link Interface} to add
	 */
	public void addInterface(Interface iface) {
		if (interfaces.containsKey(iface)) {
			throw new IllegalStateException();
		}
		
		this.interfaces.put(iface, null);
	}
	
	
	public Collection<Interface> getAllInterfaces() {
		return interfaces.keySet();
	}
}